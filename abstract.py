from abc import ABC, abstractmethod
from enum import Enum
from numpy import ndarray, random


class DomainClamping(Enum):
    """
    Когда агент движется, он может выйти за пределы области определения.
    Перечисление вариантов того, как можно с этим бороться.

    ALLOW_CROSSING - разрешить пересечение, пусть за границей области
      определения и остается (можно задать заведомо большое значение)
    STOP_ON_BOUNDARY - остановиться на границе в направлении движения
    STAND_STILL - не совершать движения, остаться на прежнем месте
    FOR_EACH_COMPONENT - если область определения - гиперкуб, то
      можно отдельно рассматривать каждую компоненту, приводя ее
      на границу
    """

    ALLOW_CROSSING = 0
    STOP_ON_BOUNDARY = 1
    STAND_STILL = 2
    FOR_EACH_COMPONENT = 3


class AbstractFunc(ABC):
    """
    Абстрактный класс функции, которую нужно минимизировать.

    Каждый алгоритм минимизации ожидает его в качестве аргумента,
    то есть функцию, наследующуюся от данного класса. Данный класс принуждает
    своих наследников реализовывать свои методы.

    Функция = вычисление значения + область определения.
    Про свою область определения знает только функция, поэтому
    она отвечает за генерацию новых точек в ней и движения агентов.
    """

    @abstractmethod
    def __init__(self):
        """
        Инициализация функции.

        eval_calls - сколько раз было вызвано вычисление функции. Требуется для отслеживания
          эффективности алгоритмов.
        rand_calls - сколько раз была вызвана генерация случайной точки. Требуется также для
          отслеживания эффективности алгоритмов, хотя eval_calls предпочтительней, т.к. не все
          алгоритмы постоянно генерируют новые точки.
        Инициализируются нулями, как там дальше изменяются - это уже дело классов-наследников
        """

        self.eval_calls = 0
        self.rand_calls = 0

    @abstractmethod
    def __call__(self, coord: ndarray):
        """
        Вызов экземляра объекта как функции в некоторой точке (точках)

        Может быть передана одна точка, а может быть и целое множество.
        При этом множество можно передать как numpy.ndarray, тогда выражение
        для одной точки из арифметических операций и numpy-функций будет выполнено
        поэлементно для каждой точки всего множества.
        """

        pass

    @abstractmethod
    def within_domain(self, coord: ndarray) -> bool:
        """
        Возвращает True, если точка находится внутри области определения, False иначе
        """

        pass

    @abstractmethod
    def move_coord(self, coord: ndarray, by: ndarray, clamp: DomainClamping) -> bool:
        """
        Двигает данный coord на вектор by.

        При выходе за границу области определения обращается к clamp.
        Предполагается, что coord представляет одну точку.

        Так как coord - не примитив, то передается по ссылке и может быть
        изменен внутри функции, и изменения будут видны извне.

        Возвращает True, если была попытка выхода за границу области определения,
        False иначе
        """

        pass

    @abstractmethod
    def domain_random(self):
        """Случайная точка в области определения с равномерным распределением"""
        pass

    @abstractmethod
    def neigh_random(self, coord: ndarray, neigh: float):
        """
        Случайная точка в окрестности размера neigh точки coord в пересечении с
        областью определения с равномерным распределением
        Окрестность может квадратной, круглой, еще какой-нибудь, но neigh -
        какое-то число, параметр окрестности, чтоб было за что зацепиться
        """

        pass

    @abstractmethod
    def domain_size(self):
        """
        Какой-то параметр области определения, например длина стороны, если
        область определения - гиперкуб. Тоже просто какое-то число, чтобы было
        за что зацепиться
        """

        pass

    @abstractmethod
    def dim(self):
        """Размерность функции, кол-во принимаемых агрументов"""
        pass


class rng:
    """
    Random Number Generator - синглтон - один инстанс на все модули
    Доки numpy говорят использовать объект np.random.default_rng(),
    но создавать его везде каждый раз, передавать как аргумент было неудобно, поэтому вот
    """

    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = random.default_rng()
        return cls._instance

    def reseed(seed: int):
        rng._instance = random.default_rng(seed)
